<!doctype html>
<html lang="vi">
<head>
  <meta charset="utf-8" />
  <title>Telegram Bot Web UI (Multi-chat + Media + Notification)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
  <style>
    :root {
      --bg: #0f1520;
      --panel: #121826;
      --accent: #2a69ff;
      --text: #e8eefc;
      --muted: #a9b3c9;
      --bubble-left: #1b2233;
      --bubble-right: #2f80ff;
      --bubble-right-text: #ffffff;
      --border: #1f2638;
      --danger: #b23b3b;
      --success: #2aa84a;
      --warning: #ffb347;
    }
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body {
      background: var(--bg);
      color: var(--text);
      font-family: system-ui, -apple-system, 'Segoe UI', Roboto, sans-serif;
      display: flex; flex-direction: column; height: 100vh;
    }
    .app { display: flex; flex: 1; overflow: hidden; position: relative; }

    /* Sidebar */
    .sidebar {
      width: 100%; max-width: 300px;
      border-right: 1px solid var(--border);
      background: var(--panel);
      display: flex; flex-direction: column;
      transition: transform 0.3s ease;
    }
    .sidebar.hidden-mobile {
      transform: translateX(-100%);
    }
    .sidebar-header {
      display: flex; align-items: center; justify-content: space-between;
      padding: 12px; border-bottom: 1px solid var(--border);
    }
    .app-title { font-weight: 600; font-size: 1.1rem; }
    .search {
      padding: 8px; border-bottom: 1px solid var(--border);
    }
    .search-wrapper {
      position: relative;
    }
    .search input {
      width: 100%; padding: 8px 32px 8px 8px; border-radius: 8px;
      border: 1px solid var(--border); background: #0b1020; color: var(--text);
    }
    .search-btn {
      position: absolute; right: 4px; top: 50%; transform: translateY(-50%);
      background: var(--accent); border: none; color: white;
      width: 28px; height: 28px; border-radius: 6px; cursor: pointer;
      display: grid; place-items: center;
    }
    .chat-list { overflow-y: auto; flex: 1; }
    .chat-empty {
      color: var(--muted); font-size: 0.85rem; text-align: center; padding: 16px;
    }
    .chat-item {
      display: grid;
      grid-template-columns: 36px 1fr auto;
      gap: 8px; padding: 10px; cursor: pointer;
      border-bottom: 1px solid var(--border);
      align-items: center;
    }
    .chat-item:hover { background: #161d2e; }
    .chat-item.active { background: #141a2a; }
    .avatar {
      width: 36px; height: 36px; border-radius: 50%;
      background: #243050; display: grid; place-items: center;
      font-weight: 700; color: #dce6ff; font-size: 0.9rem;
    }
    .info .name {
      font-weight: 600; font-size: 0.95rem; line-height: 1.2;
      overflow: hidden; text-overflow: ellipsis; white-space: nowrap;
    }
    .info .last {
      color: var(--muted); font-size: 0.8rem;
      overflow: hidden; text-overflow: ellipsis; white-space: nowrap;
    }
    .badge {
      background: var(--accent); color: white; min-width: 20px;
      height: 20px; padding: 0 5px; border-radius: 10px;
      display: grid; place-items: center; font-size: 0.75rem;
    }
    .badge.hidden { display: none; }

    /* Chat main */
    .chat {
      flex: 1; display: grid;
      grid-template-rows: auto 1fr auto;
    }
    .chat-header {
      display: flex; align-items: center; justify-content: space-between;
      padding: 10px 12px; border-bottom: 1px solid var(--border);
      background: var(--panel);
    }
    .header-left { display: flex; align-items: center; gap: 8px; }
    .header-title { font-weight: 600; font-size: 1rem; }
    .status { font-size: 0.8rem; color: var(--muted); }
    .header-actions { display: flex; gap: 8px; }
    .icon-btn {
      background: transparent; border: none; color: var(--text);
      cursor: pointer; padding: 6px; border-radius: 6px;
      font-size: 1.1rem; display: grid; place-items: center;
    }
    .icon-btn:hover { background: #1f2638; }
    .menu-toggle { display: none; }

    /* Messages */
    .messages {
      padding: 12px; overflow-y: auto; background: #0e1423;
      display: flex; flex-direction: column; gap: 6px;
    }
    .message {
      position: relative; word-wrap: break-word; white-space: pre-wrap;
      font-size: 0.9rem; border-radius: 12px; padding: 8px 10px;
      max-width: 75%; cursor: pointer;
    }
    .message:hover { opacity: 0.9; }
    .message.left { background: var(--bubble-left); align-self: flex-start; }
    .message.right { background: var(--bubble-right); color: var(--bubble-right-text); align-self: flex-end; }
    .message.reply {
      border-left: 4px solid var(--accent); padding-left: 14px;
    }
    .meta { font-size: 0.75rem; color: var(--muted); margin-top: 4px; }
    .reply-to {
      font-size: 0.75rem; color: var(--muted); margin-bottom: 4px;
      border-left: 3px solid var(--muted); padding-left: 6px; cursor: pointer;
    }
    .msg-actions {
      position: absolute; top: 4px; right: 4px;
      background: rgba(0,0,0,0.7); border-radius: 6px;
      padding: 2px; display: none; gap: 4px;
    }
    .message:hover .msg-actions { display: flex; }
    .msg-action-btn {
      background: transparent; border: none; color: white;
      cursor: pointer; padding: 4px 8px; border-radius: 4px;
      font-size: 0.75rem;
    }
    .msg-action-btn:hover { background: rgba(255,255,255,0.2); }

    /* Composer */
    .composer {
      display: grid; grid-template-columns: auto 1fr auto; gap: 8px;
      padding: 8px; border-top: 1px solid var(--border); background: var(--panel);
      align-items: center;
    }
    .composer .reply-context {
      grid-column: 1 / -1; display: flex; align-items: center;
      background: var(--bubble-left); padding: 4px 8px; border-radius: 8px;
      font-size: 0.8rem; color: var(--muted);
    }
    .composer .reply-context .cancel-reply {
      margin-left: auto; cursor: pointer; font-weight: bold;
    }
    .composer input[type="text"] {
      padding: 8px 10px; border-radius: 8px; border: 1px solid var(--border);
      background: #0b1020; color: var(--text); font-size: 0.9rem;
    }
    .btn {
      padding: 8px 12px; border: none; border-radius: 8px;
      background: var(--accent); color: white; cursor: pointer; font-size: 0.9rem;
    }
    .btn.secondary { background: #34425f; }
    .btn.danger { background: var(--danger); }
    .btn.success { background: var(--success); }
    .btn.hidden { display: none; }

    /* "Xem tin nh·∫Øn m·ªõi" button */
    #newMsgBtn {
      position: fixed; bottom: 80px; right: 16px;
      padding: 8px 12px; background: var(--accent); color: white;
      border-radius: 20px; cursor: pointer; font-size: 0.85rem;
      display: none; z-index: 100; border: none;
    }

    /* Responsive */
    @media (max-width: 768px) {
      .sidebar {
        position: absolute; left: 0; top: 0; bottom: 0;
        z-index: 10; max-width: 280px;
      }
      .menu-toggle { display: block; }
      .chat-header .header-title { font-size: 0.95rem; }
      .composer { grid-template-columns: 1fr auto auto; }
    }

    /* Overlay/Dialog */
    .overlay {
      position: fixed; inset: 0; background: rgba(0,0,0,0.5);
      display: grid; place-items: center; z-index: 100;
    }
    .overlay.hidden { display: none; }
    .dialog {
      width: 90%; max-width: 480px; background: var(--panel);
      border: 1px solid var(--border); border-radius: 12px;
      padding: 16px; max-height: 80vh; overflow-y: auto;
    }
    .dialog h3 { margin: 0 0 8px; }
    .dialog p { margin: 0 0 12px; color: var(--muted); }
    .dialog input, .dialog select {
      width: 100%; padding: 10px 12px; border-radius: 10px;
      border: 1px solid var(--border); background: #0b1020;
      color: var(--text); margin-bottom: 12px;
    }
    .dialog .row { display: flex; gap: 8px; margin-bottom: 12px; }
    .dialog .row input { flex: 1; margin-bottom: 0; }
    .actions { display: flex; gap: 8px; justify-content: space-between; align-items: center; flex-wrap: wrap; }
    .hint { font-size: 12px; color: var(--muted); min-height: 16px; }

    /* Members dialog */
    .members-list {
      max-height: 300px; overflow-y: auto;
      border: 1px solid var(--border); border-radius: 8px;
      background: #0b1020; margin-bottom: 12px;
    }
    .member-item {
      display: flex; align-items: center; justify-content: space-between;
      padding: 8px; border-bottom: 1px solid var(--border);
    }
    .member-item:last-child { border-bottom: none; }
    .member-info { flex: 1; }
    .member-name { font-weight: 600; font-size: 0.9rem; }
    .member-status { font-size: 0.75rem; color: var(--muted); }
    .member-actions { display: flex; gap: 4px; }

    /* Toasts */
    .toasts {
      position: fixed; right: 16px; bottom: 16px;
      display: flex; flex-direction: column; gap: 8px; z-index: 200;
    }
    .toast {
      background: #18223a; color: var(--text);
      border: 1px solid var(--border); border-radius: 10px;
      padding: 10px 12px; box-shadow: 0 2px 6px rgba(0,0,0,0.3);
      min-width: 220px;
    }
    .toast .title { font-weight: 600; }
    .toast .body { font-size: 13px; color: var(--muted); }
  </style>
</head>
<body>
  <div class="app">
    <aside id="sidebar" class="sidebar">
      <div class="sidebar-header">
        <div class="app-title">Telegram Bot</div>
        <button id="settingsBtn" class="btn secondary">C√†i ƒë·∫∑t</button>
      </div>
      <div class="search">
        <div class="search-wrapper">
          <input id="searchInput" type="text" placeholder="T√¨m chat ID ho·∫∑c @username" />
          <button id="searchBtn" class="search-btn">üîç</button>
        </div>
      </div>
      <div id="chatList" class="chat-list">
        <div id="emptyNotice" class="chat-empty">
          Ch∆∞a c√≥ cu·ªôc tr√≤ chuy·ªán. Khi c√≥ tin nh·∫Øn ƒë·∫øn, m·ª•c s·∫Ω hi·ªán ·ªü ƒë√¢y.
        </div>
      </div>
    </aside>

    <main class="chat">
      <div class="chat-header">
        <div class="header-left">
          <button id="menuToggle" class="icon-btn menu-toggle">‚ò∞</button>
          <div id="activeAvatar" class="avatar" style="display:none;">?</div>
          <div>
            <div id="headerTitle" class="header-title">Ch∆∞a ch·ªçn cu·ªôc tr√≤ chuy·ªán</div>
            <div id="status" class="status">Ch∆∞a k·∫øt n·ªëi</div>
          </div>
        </div>
        <div class="header-actions">
          <button id="membersBtn" class="icon-btn" title="Qu·∫£n l√Ω th√†nh vi√™n" style="display:none;">üë•</button>
          <div id="botInfo" class="status"></div>
        </div>
      </div>

      <div id="messages" class="messages"></div>
      <button id="newMsgBtn">‚Üì Xem tin m·ªõi</button>

      <div class="composer">
        <div id="replyContext" class="reply-context hidden">
          ƒêang tr·∫£ l·ªùi: <span id="replyText"></span>
          <span id="cancelReply" class="cancel-reply">‚úï</span>
        </div>
        <button id="attachBtn" class="btn secondary">üìé</button>
        <input id="input" type="text" placeholder="Nh·∫≠p tin nh·∫Øn..." disabled />
        <button id="sendBtn" class="btn" disabled>G·ª≠i</button>
        <input id="fileInput" type="file" style="display:none" />
      </div>
    </main>
  </div>

  <!-- Settings Overlay -->
  <div id="overlay" class="overlay hidden">
    <div class="dialog">
      <h3>C√†i ƒë·∫∑t k·∫øt n·ªëi</h3>
      <p>
        Nh·∫≠p Bot Token (t·ª´ BotFather). Danh s√°ch cu·ªôc tr√≤ chuy·ªán s·∫Ω t·ª± xu·∫•t hi·ªán
        khi bot nh·∫≠n tin nh·∫Øn m·ªõi. Token ƒë∆∞·ª£c l∆∞u t·∫°i localStorage ‚Äî ch·ªâ d√πng ƒë·ªÉ th·ª≠ nghi·ªám c√° nh√¢n.
      </p>
      <input id="tokenInput" type="password" placeholder="Bot Token (botXXXXXXXX:YYYYYYYYYYYYYYYY)" />
      <div class="row">
        <input id="proxyInput" type="text" placeholder="CORS proxy prefix (tu·ª≥ ch·ªçn, vd: https://cors.isomorphic-git.org/)" />
        <button id="testBtn" class="btn secondary">Ki·ªÉm tra</button>
      </div>
      <div class="row">
        <button id="deleteWebhookBtn" class="btn danger">X√≥a webhook</button>
        <button id="notifBtn" class="btn secondary">B·∫≠t th√¥ng b√°o</button>
      </div>
      <div class="actions">
        <div class="hint" id="settingsHint">
          N·∫øu nh·∫≠n l·ªói 409 khi polling, h√£y x√≥a webhook. N·∫øu b·ªã CORS, th√™m proxy prefix.
        </div>
        <div>
          <button id="saveBtn" class="btn">L∆∞u & K·∫øt n·ªëi</button>
          <button id="cancelBtn" class="btn secondary">ƒê√≥ng</button>
        </div>
      </div>
    </div>
  </div>

  <!-- Members Dialog -->
  <div id="membersOverlay" class="overlay hidden">
    <div class="dialog">
      <h3>Qu·∫£n l√Ω th√†nh vi√™n</h3>
      <p id="groupInfo">ƒêang t·∫£i...</p>
      <div id="membersList" class="members-list"></div>
      <div class="actions">
        <div class="hint" id="membersHint"></div>
        <button id="closeMembersBtn" class="btn secondary">ƒê√≥ng</button>
      </div>
    </div>
  </div>

  <!-- Toasts -->
  <div id="toasts" class="toasts"></div>

  <script>
  // === Elements ===
  const chatListEl      = document.getElementById('chatList');
  const emptyNoticeEl   = document.getElementById('emptyNotice');
  const messagesEl      = document.getElementById('messages');
  const inputEl         = document.getElementById('input');
  const sendBtn         = document.getElementById('sendBtn');
  const attachBtn       = document.getElementById('attachBtn');
  const fileInputEl     = document.getElementById('fileInput');
  const statusEl        = document.getElementById('status');
  const botInfoEl       = document.getElementById('botInfo');
  const headerTitleEl   = document.getElementById('headerTitle');
  const activeAvatarEl  = document.getElementById('activeAvatar');
  const newMsgBtn       = document.getElementById('newMsgBtn');
  const sidebarEl       = document.getElementById('sidebar');
  const menuToggleEl    = document.getElementById('menuToggle');
  const searchInputEl   = document.getElementById('searchInput');
  const searchBtnEl     = document.getElementById('searchBtn');
  const membersBtnEl    = document.getElementById('membersBtn');

  const overlayEl           = document.getElementById('overlay');
  const settingsBtn         = document.getElementById('settingsBtn');
  const saveBtn             = document.getElementById('saveBtn');
  const cancelBtn           = document.getElementById('cancelBtn');
  const tokenInputEl        = document.getElementById('tokenInput');
  const proxyInputEl        = document.getElementById('proxyInput');
  const testBtn             = document.getElementById('testBtn');
  const deleteWebhookBtn    = document.getElementById('deleteWebhookBtn');
  const settingsHintEl      = document.getElementById('settingsHint');
  const notifBtn            = document.getElementById('notifBtn');

  const membersOverlayEl    = document.getElementById('membersOverlay');
  const membersListEl       = document.getElementById('membersList');
  const closeMembersBtn     = document.getElementById('closeMembersBtn');
  const groupInfoEl         = document.getElementById('groupInfo');
  const membersHintEl       = document.getElementById('membersHint');

  const toastsEl = document.getElementById('toasts');

  // === State & History per-bot ===
  let token = localStorage.getItem('bot_token') || '';
  const storageKey = token ? ('chat_history_' + token) : null;
  let chats = new Map();
  if (storageKey) {
    try {
      const arr = JSON.parse(localStorage.getItem(storageKey) || '[]');
      for (const [k,v] of arr) {
        chats.set(k, {
          ...v,
          messageIds: new Set(v.messageIds),
        });
      }
    } catch {}
  }
  let activeChatId = null;
  let lastUpdateId = parseInt(localStorage.getItem('last_update_id')||'0',10) || 0;
  let bot = { id: null, username: null, name: null };

  // reply
  let replyTo = null;
  function setReplyContext(msgId, preview) {
    replyTo = msgId;
    document.getElementById('replyText').textContent = preview;
    document.getElementById('replyContext').classList.remove('hidden');
  }
  function clearReplyContext() {
    replyTo = null;
    document.getElementById('replyContext').classList.add('hidden');
  }

  // save history
  function saveHistory() {
    if (!storageKey) return;
    const arr = Array.from(chats.entries()).map(([k,v])=>[
      k,
      { ...v, messageIds: [...v.messageIds] }
    ]);
    localStorage.setItem(storageKey, JSON.stringify(arr));
  }

  // helpers
  function fmtTime(tsMs) {
    const d = new Date(tsMs);
    return d.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
  }
  function initials(text) {
    const t = (text||'').trim();
    if (!t) return '?';
    const words = t.split(/\s+/).filter(Boolean);
    const a = words[0]?.[0]||'';
    const b = words[1]?.[0]||'';
    return (a+b).toUpperCase()||a.toUpperCase()||'?';
  }
  function snippet(text) {
    return (text||'').replace(/\s+/g,' ').slice(0,60);
  }
  function baseUrl() { return 'https://api.telegram.org'; }
  function fullUrl(method) {
    const u = `${baseUrl()}/bot${token}/${method}`;
    const p = proxyInputEl.value.trim();
    return p? p.replace(/\/+$/,'') + '/' + u : u;
  }
  function fullFileUrl(fp) {
    const u = `${baseUrl()}/file/bot${token}/${fp}`;
    const p = proxyInputEl.value.trim();
    return p? p.replace(/\/+$/,'') + '/' + u : u;
  }

  async function botGet(method, params) {
    const q = params ? '?' + new URLSearchParams(params).toString() : '';
    const res = await fetch(fullUrl(method)+q);
    return res.json();
  }
  async function botPost(method, body) {
    const res = await fetch(fullUrl(method), {
      method:'POST',
      headers:{'Content-Type':'application/json'},
      body: JSON.stringify(body||{})
    });
    return res.json();
  }
  async function botForm(method, formData) {
    const res = await fetch(fullUrl(method), {
      method:'POST', body: formData
    });
    return res.json();
  }

  // Toggle sidebar
  menuToggleEl.addEventListener('click', () => {
    sidebarEl.classList.toggle('hidden-mobile');
  });

  // Auto-hide sidebar on mobile when selecting chat
  function hideSidebarOnMobile() {
    if (window.innerWidth <= 768) {
      sidebarEl.classList.add('hidden-mobile');
    }
  }

  // Chat action typing
  let actionTimer = null;
  function sendChatAction() {
    if (!activeChatId||!token) return;
    botPost('sendChatAction',{chat_id:activeChatId,action:'typing'}).catch(()=>{});
  }
  function startChatAction() {
    sendChatAction();
    actionTimer = setInterval(sendChatAction,4000);
  }
  function stopChatAction() {
    clearInterval(actionTimer); actionTimer=null;
  }

  // render chat list
  function renderChatList() {
    const items = Array.from(chats.values()).sort((a,b)=>(b.lastDate||0)-(a.lastDate||0));
    chatListEl.innerHTML = '';
    if (!items.length) {
      chatListEl.appendChild(emptyNoticeEl);
      emptyNoticeEl.style.display = 'block';
      return;
    }
    emptyNoticeEl.style.display = 'none';
    for (const c of items) {
      const el = document.createElement('div');
      el.className = 'chat-item' + (c.id===activeChatId?' active':'');
      el.dataset.chatId = c.id;
      el.innerHTML = `
        <div class="avatar">${c.avatarText}</div>
        <div class="info">
          <div class="name">${c.title}</div>
          <div class="last">${c.lastText?snippet(c.lastText):'‚Äî'}</div>
        </div>
        <div class="badge${c.unread? '':' hidden'}">${c.unread||''}</div>
      `;
      el.addEventListener('click', ()=>openChat(c.id));
      chatListEl.appendChild(el);
    }
    saveHistory();
  }

  // open chat
  function openChat(chatId) {
    activeChatId = String(chatId);
    const chat = chats.get(activeChatId);
    if (!chat) return;
    headerTitleEl.textContent = chat.title;
    activeAvatarEl.style.display = 'grid';
    activeAvatarEl.textContent = chat.avatarText;
    inputEl.disabled = false;
    sendBtn.disabled = false;
    attachBtn.disabled = false;
    inputEl.placeholder = 'Nh·∫≠p tin nh·∫Øn...';
    inputEl.focus();
    chat.unread = 0;
    
    // Show members button for groups
    if (chat.type === 'group' || chat.type === 'supergroup') {
      membersBtnEl.style.display = 'block';
    } else {
      membersBtnEl.style.display = 'none';
    }
    
    renderChatList();
    messagesEl.innerHTML = '';
    for (const m of chat.messages) renderMessage(m);
    scrollToBottom();
    hideSidebarOnMobile();
  }

  // render 1 message
  function renderMessage(m) {
    const item = document.createElement('div');
    item.className = 'message ' + (m.side==='right'?'right':'left') + (m.reply_to?' reply':'');
    item.dataset.msgId = m.id;
    
    // Message actions
    const actions = document.createElement('div');
    actions.className = 'msg-actions';
    if (m.side === 'right') {
      const delBtn = document.createElement('button');
      delBtn.className = 'msg-action-btn';
      delBtn.textContent = 'üóëÔ∏è';
      delBtn.title = 'X√≥a tin nh·∫Øn';
      delBtn.addEventListener('click', (e) => {
        e.stopPropagation();
        deleteMessage(m.id);
      });
      actions.appendChild(delBtn);
    }
    item.appendChild(actions);
    
    // reply preview
    if (m.reply_preview) {
      const rt = document.createElement('div');
      rt.className = 'reply-to';
      rt.textContent = '‚Ü™ ' + m.reply_preview;
      item.appendChild(rt);
    }
    // n·ªôi dung
    const cnt = document.createElement('div');
    if (m.type==='photo') {
      const img = document.createElement('img');
      img.src = m.mediaUrl; img.className='media'; img.alt=m.caption||'·∫¢nh';
      cnt.appendChild(img);
      if (m.caption) { const t=document.createElement('div'); t.textContent=m.caption; t.style.marginTop='6px'; cnt.appendChild(t);}
    }
    else if (m.type==='video') {
      const v=document.createElement('video');
      v.src=m.mediaUrl; v.controls=true; v.playsInline=true; v.className='media';
      cnt.appendChild(v);
      if (m.caption) { const t=document.createElement('div'); t.textContent=m.caption; t.style.marginTop='6px'; cnt.appendChild(t);}
    }
    else if (m.type==='audio'||m.type==='voice') {
      const a=document.createElement('audio');
      a.src=m.mediaUrl; a.controls=true; a.className='media';
      cnt.appendChild(a);
      if (m.caption) { const t=document.createElement('div'); t.textContent=m.caption; t.style.marginTop='6px'; cnt.appendChild(t);}
    }
    else if (m.type==='document') {
      const a=document.createElement('a');
      a.href=m.mediaUrl; a.target='_blank'; a.rel='noopener noreferrer';
      a.className='doc-link'; a.textContent=m.fileName||'T·ªáp';
      cnt.appendChild(a);
      if (m.caption) { const t=document.createElement('div'); t.textContent=m.caption; t.style.marginTop='6px'; cnt.appendChild(t);}
    }
    else if (m.type==='sticker') {
      if (m.stickerFormat==='webp') {
        const img=document.createElement('img');
        img.src=m.mediaUrl; img.className='media'; img.alt=m.emoji||'Sticker';
        cnt.appendChild(img);
      } else if (m.stickerFormat==='webm') {
        const v=document.createElement('video');
        v.src=m.mediaUrl; v.autoplay=true; v.loop=true; v.muted=true; v.playsInline=true; v.className='media';
        cnt.appendChild(v);
      } else {
        cnt.textContent='[Sticker] ' + (m.emoji||'');
      }
    }
    else {
      cnt.textContent = m.text;
    }
    item.appendChild(cnt);
    const meta = document.createElement('div');
    meta.className='meta';
    meta.textContent = `${m.fromName} ‚Ä¢ ${fmtTime(m.date)}`;
    item.appendChild(meta);
    messagesEl.appendChild(item);
  }

  // Delete message
  async function deleteMessage(messageId) {
    if (!confirm('B·∫°n c√≥ ch·∫Øc mu·ªën x√≥a tin nh·∫Øn n√†y?')) return;
    try {
      const res = await botPost('deleteMessage', {
        chat_id: activeChatId,
        message_id: parseInt(messageId, 10)
      });
      if (res.ok) {
        const chat = chats.get(activeChatId);
        if (chat) {
          chat.messages = chat.messages.filter(m => m.id !== messageId);
          chat.messageIds.delete(messageId);
          saveHistory();
          messagesEl.innerHTML = '';
          for (const m of chat.messages) renderMessage(m);
        }
        toastsShow('‚úÖ Th√†nh c√¥ng', 'ƒê√£ x√≥a tin nh·∫Øn');
      } else {
        toastsShow('‚ùå L·ªói', res.description || 'Kh√¥ng th·ªÉ x√≥a tin nh·∫Øn');
      }
    } catch(e) {
      toastsShow('‚ùå L·ªói', 'L·ªói m·∫°ng: ' + e.message);
    }
  }

  // th√™m message v√†o chat
  function addMessageToChat(chatId, m, incoming) {
    const chat = chats.get(String(chatId));
    if (!chat) return;
    if (chat.messageIds.has(m.id)) return;
    chat.messageIds.add(m.id);
    chat.messages.push(m);
    chat.lastText = m.type==='text'?m.text:(m.caption||m.text||'['+m.type+']');
    chat.lastDate = m.date;
    if (activeChatId===chat.id) {
      renderMessage(m);
      scrollToBottom();
    } else if (incoming) {
      chat.unread = (chat.unread||0) + 1;
      notifyNewMessage(chat, m);
    }
    renderChatList();
    if (incoming) maybeShowNewMsgBtn();
  }

  function senderNameFromMsg(msg) {
    if (msg.from) {
      const n = [msg.from.first_name, msg.from.last_name].filter(Boolean).join(' ');
      return n||msg.from.username||'Ng∆∞·ªùi d√πng';
    }
    if (msg.author_signature) return msg.author_signature;
    return 'H·ªá th·ªëng';
  }

  function toastsShow(title, body) {
    const t=document.createElement('div'); t.className='toast';
    const ttl=document.createElement('div'); ttl.className='title'; ttl.textContent=title;
    const bd=document.createElement('div'); bd.className='body'; bd.textContent=body;
    t.appendChild(ttl); t.appendChild(bd);
    toastsEl.appendChild(t);
    setTimeout(()=>t.remove(),4000);
  }
  function playBeep() {
    try {
      const ctx=new (window.AudioContext||window.webkitAudioContext)();
      const o=ctx.createOscillator(), g=ctx.createGain();
      o.type='sine'; o.frequency.value=680; g.gain.value=0.04;
      o.connect(g); g.connect(ctx.destination);
      o.start(); setTimeout(()=>{o.stop();ctx.close();},180);
    }catch{}
  }
  function notifyNewMessage(chat, m) {
    const body = chat.lastText||snippet(m.text||m.caption||'['+(m.type||'tin nh·∫Øn')+']');
    toastsShow(chat.title, body); playBeep();
    if (Notification.permission==='granted') {
      try { new Notification(chat.title,{body}); } catch{}
    }
  }
  async function getFileUrl(file_id) {
    const info = await botGet('getFile',{file_id});
    if (!info.ok) throw new Error(info.description);
    const url = fullFileUrl(info.result.file_path);
    return url;
  }

  // Xem tin m·ªõi
  function scrollToBottom() {
    messagesEl.scrollTop = messagesEl.scrollHeight;
  }
  function maybeShowNewMsgBtn() {
    const atBottom = (messagesEl.scrollTop + messagesEl.clientHeight) >= (messagesEl.scrollHeight-20);
    if (!atBottom) newMsgBtn.style.display='block';
  }
  newMsgBtn.addEventListener('click', ()=>{
    scrollToBottom();
    newMsgBtn.style.display='none';
  });

  // x·ª≠ l√Ω reply khi click v√†o message
  messagesEl.addEventListener('click', e=>{
    if (e.target.closest('.msg-action-btn')) return;
    const msgEl = e.target.closest('.message');
    if (!msgEl) return;
    const msgId = msgEl.dataset.msgId;
    const prev = msgEl.innerText.slice(0,30).replace('/ /g',' ');
    setReplyContext(msgId, prev);
  });
  document.getElementById('cancelReply').addEventListener('click', clearReplyContext);

  // Search functionality
  async function searchChat() {
    const query = searchInputEl.value.trim();
    if (!query) {
      toastsShow('‚ö†Ô∏è Ch√∫ √Ω', 'Vui l√≤ng nh·∫≠p chat ID ho·∫∑c username');
      return;
    }
    
    try {
      let chatId = query;
      
      // If starts with @, it's a username
      if (query.startsWith('@')) {
        const username = query.substring(1);
        toastsShow('üîç ƒêang t√¨m...', 'T√¨m ki·∫øm @' + username);
        
        // Try to send a message to get chat info (will fail but gives us the chat)
        // Better way: use getChat but need chat_id
        // For username, we need to try sending a message or use deep linking
        chatId = '@' + username;
      }
      
      // Try to get chat info
      const res = await botPost('getChat', { chat_id: chatId });
      
      if (res.ok) {
        const c = res.result;
        const id = String(c.id);
        
        if (!chats.has(id)) {
          const isPrivate = c.type === 'private';
          const title = isPrivate
            ? [c.first_name, c.last_name].filter(Boolean).join(' ') || c.username || 'Ng∆∞·ªùi d√πng'
            : (c.title || (c.type || 'Chat'));
          
          chats.set(id, {
            id,
            type: c.type,
            title,
            avatarText: initials(title),
            messages: [],
            messageIds: new Set(),
            lastText: '',
            lastDate: 0,
            unread: 0
          });
          
          renderChatList();
          toastsShow('‚úÖ T√¨m th·∫•y', title);
        }
        
        openChat(id);
        searchInputEl.value = '';
      } else {
        toastsShow('‚ùå Kh√¥ng t√¨m th·∫•y', res.description || 'Chat kh√¥ng t·ªìn t·∫°i ho·∫∑c bot ch∆∞a c√≥ quy·ªÅn truy c·∫≠p');
      }
    } catch(e) {
      toastsShow('‚ùå L·ªói', 'L·ªói khi t√¨m ki·∫øm: ' + e.message);
    }
  }
  
  searchBtnEl.addEventListener('click', searchChat);
  searchInputEl.addEventListener('keydown', e => {
    if (e.key === 'Enter') searchChat();
  });

  // Members management
  async function showMembers() {
    if (!activeChatId) return;
    const chat = chats.get(activeChatId);
    if (!chat || (chat.type !== 'group' && chat.type !== 'supergroup')) {
      toastsShow('‚ö†Ô∏è Ch√∫ √Ω', 'Ch·ªâ √°p d·ª•ng cho nh√≥m');
      return;
    }
    
    membersOverlayEl.classList.remove('hidden');
    groupInfoEl.textContent = `Nh√≥m: ${chat.title}`;
    membersListEl.innerHTML = '<div style="padding:20px;text-align:center;">ƒêang t·∫£i...</div>';
    membersHintEl.textContent = '';
    
    try {
      // Get chat administrators
      const admins = await botPost('getChatAdministrators', { chat_id: activeChatId });
      
      if (admins.ok) {
        membersListEl.innerHTML = '';
        
        if (admins.result.length === 0) {
          membersListEl.innerHTML = '<div style="padding:20px;text-align:center;color:var(--muted);">Kh√¥ng c√≥ th√†nh vi√™n</div>';
          return;
        }
        
        for (const member of admins.result) {
          const item = document.createElement('div');
          item.className = 'member-item';
          
          const info = document.createElement('div');
          info.className = 'member-info';
          
          const name = document.createElement('div');
          name.className = 'member-name';
          name.textContent = [member.user.first_name, member.user.last_name].filter(Boolean).join(' ') || member.user.username || 'User';
          
          const status = document.createElement('div');
          status.className = 'member-status';
          status.textContent = member.status === 'creator' ? 'üëë Ch·ªß nh√≥m' : 
                              member.status === 'administrator' ? '‚≠ê Qu·∫£n tr·ªã vi√™n' : 
                              member.status;
          
          info.appendChild(name);
          info.appendChild(status);
          
          const actions = document.createElement('div');
          actions.className = 'member-actions';
          
          // Only show actions if not creator and bot has rights
          if (member.status !== 'creator') {
            const kickBtn = document.createElement('button');
            kickBtn.className = 'btn danger';
            kickBtn.style.fontSize = '0.75rem';
            kickBtn.style.padding = '4px 8px';
            kickBtn.textContent = 'Kick';
            kickBtn.addEventListener('click', () => kickMember(member.user.id, name.textContent));
            
            const promoteBtn = document.createElement('button');
            promoteBtn.className = 'btn secondary';
            promoteBtn.style.fontSize = '0.75rem';
            promoteBtn.style.padding = '4px 8px';
            promoteBtn.textContent = member.status === 'administrator' ? 'H·∫° quy·ªÅn' : 'ThƒÉng quy·ªÅn';
            promoteBtn.addEventListener('click', () => toggleAdmin(member.user.id, member.status !== 'administrator', name.textContent));
            
            actions.appendChild(promoteBtn);
            actions.appendChild(kickBtn);
          }
          
          item.appendChild(info);
          item.appendChild(actions);
          membersListEl.appendChild(item);
        }
        
        membersHintEl.textContent = `${admins.result.length} qu·∫£n tr·ªã vi√™n`;
      } else {
        membersListEl.innerHTML = `<div style="padding:20px;text-align:center;color:var(--danger);">L·ªói: ${res.description || 'Kh√¥ng th·ªÉ t·∫£i th√†nh vi√™n'}</div>`;
        membersHintEl.textContent = 'Bot c·∫ßn l√† qu·∫£n tr·ªã vi√™n ƒë·ªÉ xem danh s√°ch';
      }
    } catch(e) {
      membersListEl.innerHTML = `<div style="padding:20px;text-align:center;color:var(--danger);">L·ªói m·∫°ng: ${e.message}</div>`;
    }
  }
  
  async function kickMember(userId, userName) {
    if (!confirm(`Kick ${userName} kh·ªèi nh√≥m?`)) return;
    
    try {
      const res = await botPost('banChatMember', {
        chat_id: activeChatId,
        user_id: userId
      });
      
      if (res.ok) {
        toastsShow('‚úÖ Th√†nh c√¥ng', `ƒê√£ kick ${userName}`);
        showMembers(); // Refresh
      } else {
        toastsShow('‚ùå L·ªói', res.description || 'Kh√¥ng th·ªÉ kick th√†nh vi√™n');
      }
    } catch(e) {
      toastsShow('‚ùå L·ªói', 'L·ªói m·∫°ng: ' + e.message);
    }
  }
  
  async function toggleAdmin(userId, promote, userName) {
    try {
      const res = await botPost('promoteChatMember', {
        chat_id: activeChatId,
        user_id: userId,
        can_manage_chat: promote,
        can_delete_messages: promote,
        can_manage_video_chats: promote,
        can_restrict_members: promote,
        can_promote_members: false,
        can_change_info: promote,
        can_invite_users: promote,
        can_pin_messages: promote
      });
      
      if (res.ok) {
        toastsShow('‚úÖ Th√†nh c√¥ng', `ƒê√£ ${promote ? 'thƒÉng' : 'h·∫°'} quy·ªÅn ${userName}`);
        showMembers(); // Refresh
      } else {
        toastsShow('‚ùå L·ªói', res.description || 'Kh√¥ng th·ªÉ thay ƒë·ªïi quy·ªÅn');
      }
    } catch(e) {
      toastsShow('‚ùå L·ªói', 'L·ªói m·∫°ng: ' + e.message);
    }
  }
  
  membersBtnEl.addEventListener('click', showMembers);
  closeMembersBtn.addEventListener('click', () => membersOverlayEl.classList.add('hidden'));

  // Bot control: getMe, polling, v.v.
  async function testConnection() {
    if (!token) { settingsHintEl.textContent='Ch∆∞a c√≥ token.'; return; }
    try {
      const me = await botGet('getMe');
      settingsHintEl.textContent = me.ok
        ? `‚úÖ OK: @${me.result.username||'(kh√¥ng t√™n)'} ‚Ä¢ id=${me.result.id}`
        : '‚ùå L·ªói getMe: '+(me.description||'Kh√¥ng r√µ');
    } catch(e) {
      settingsHintEl.textContent='‚ùå CORS ho·∫∑c m·∫°ng l·ªói: '+e.message;
    }
  }
  async function deleteWebhook() {
    if (!token) return;
    try {
      const res = await botPost('deleteWebhook',{drop_pending_updates:false});
      settingsHintEl.textContent = res.ok
        ? '‚úÖ ƒê√£ x√≥a webhook.'
        : '‚ùå Kh√¥ng x√≥a ƒë∆∞·ª£c: '+(res.description||'Kh√¥ng r√µ');
    } catch(e){
      settingsHintEl.textContent='‚ùå L·ªói m·∫°ng khi x√≥a webhook: '+e.message;
    }
  }
  function requestNotifications() {
    Notification.requestPermission().then(p=>{
      settingsHintEl.textContent = p==='granted'
        ? '‚úÖ Th√¥ng b√°o: ƒë√£ c·∫•p quy·ªÅn.'
        : '‚ùå Th√¥ng b√°o: b·ªã t·ª´ ch·ªëi ho·∫∑c ch∆∞a c·∫•p.';
    });
  }
  async function connect() {
    if (!token) { statusEl.textContent='Ch∆∞a k·∫øt n·ªëi (thi·∫øu token)'; return; }
    statusEl.textContent='ƒêang k·∫øt n·ªëi...';
    try {
      const me = await botGet('getMe');
      if (me.ok) {
        bot.id = me.result.id;
        bot.username = me.result.username || null;
        bot.name = [me.result.first_name,me.result.last_name].filter(Boolean).join(' ')||bot.username||'Bot';
        botInfoEl.textContent = bot.username? '@'+bot.username: 'Bot ID: '+bot.id;
        startPolling();
      } else {
        statusEl.textContent='L·ªói getMe: '+(me.description||'Kh√¥ng r√µ');
      }
    } catch {
      statusEl.textContent='CORS ho·∫∑c m·∫°ng l·ªói khi getMe';
    }
  }
  let pollTimer = null;
  function startPolling() {
    clearInterval(pollTimer);
    pollOnce().catch(()=>{});
    pollTimer = setInterval(()=>pollOnce().catch(()=>{}),2500);
    statusEl.textContent='ƒêang nh·∫≠n c·∫≠p nh·∫≠t...';
  }
  function stopPolling() { clearInterval(pollTimer); pollTimer=null; }
  async function pollOnce() {
    try {
      const res = await botPost('getUpdates',{
        offset: lastUpdateId||undefined,
        timeout:0,
        allowed_updates:['message','edited_message','channel_post','edited_channel_post']
      });
      if (!res.ok) {
        statusEl.textContent='L·ªói getUpdates: '+(res.description||'Kh√¥ng r√µ');
        if (String(res.error_code)==='409') {
          statusEl.textContent='Webhook ƒëang ho·∫°t ƒë·ªông. X√≥a webhook trong C√†i ƒë·∫∑t.';
        }
        return;
      }
      for (const upd of res.result||[]) {
        lastUpdateId = upd.update_id+1;
        localStorage.setItem('last_update_id',String(lastUpdateId));
        const msg = upd.message||upd.edited_message||upd.channel_post||upd.edited_channel_post;
        if (!msg||!msg.chat) continue;
        // ensure chat
        const c = msg.chat;
        const id = String(c.id);
        if (!chats.has(id)) {
          const isPrivate = c.type==='private';
          const title = isPrivate
            ? [msg.chat.first_name,msg.chat.last_name].filter(Boolean).join(' ')||msg.chat.username||'Ng∆∞·ªùi d√πng'
            : (msg.chat.title||(c.type||'Chat'));
          chats.set(id,{
            id, type:c.type, title,
            avatarText:initials(title),
            messages:[], messageIds:new Set(),
            lastText:'', lastDate:0, unread:0
          });
        }
        const chat = chats.get(id);
        const fromName = senderNameFromMsg(msg);
        const base = {
          id: msg.message_id,
          side: 'left',
          date: (msg.date||Math.floor(Date.now()/1000))*1000,
          fromName,
          reply_to: msg.reply_to_message && msg.reply_to_message.message_id,
          reply_preview: msg.reply_to_message && snippet(msg.reply_to_message.text||msg.reply_to_message.caption||'')
        };
        let m=null;
        if (msg.text) {
          m = {...base, type:'text', text:msg.text};
        } else if (msg.photo) {
          const p = msg.photo[msg.photo.length-1];
          const url = await getFileUrl(p.file_id);
          m = {...base, type:'photo', mediaUrl:url, caption:msg.caption||'', reply_to: base.reply_to, reply_preview: base.reply_preview};
        } else if (msg.video) {
          const url = await getFileUrl(msg.video.file_id);
          m = {...base, type:'video', mediaUrl:url, caption:msg.caption||'', reply_to: base.reply_to, reply_preview: base.reply_preview};
        } else if (msg.audio) {
          const url = await getFileUrl(msg.audio.file_id);
          m = {...base, type:'audio', mediaUrl:url, caption:msg.caption||'', reply_to: base.reply_to, reply_preview: base.reply_preview};
        } else if (msg.voice) {
          const url = await getFileUrl(msg.voice.file_id);
          m = {...base, type:'voice', mediaUrl:url, caption:msg.caption||'', reply_to: base.reply_to, reply_preview: base.reply_preview};
        } else if (msg.document) {
          const url = await getFileUrl(msg.document.file_id);
          m = {...base, type:'document', mediaUrl:url, caption:msg.caption||'', fileName:msg.document.file_name||'T·ªáp', reply_to: base.reply_to, reply_preview: base.reply_preview};
        } else if (msg.sticker) {
          const st = msg.sticker;
          let fmt='tgs', url='';
          if (st.is_video) {
            fmt='webm'; url=await getFileUrl(st.file_id);
          } else if (!st.is_animated) {
            fmt='webp'; url=await getFileUrl(st.file_id);
          }
          m = {...base, type:'sticker', mediaUrl:url, stickerFormat:fmt, emoji:st.emoji||'', reply_to: base.reply_to, reply_preview: base.reply_preview};
        } else {
          m = {...base, type:'text', text:'[Kh√¥ng hi·ªÉn th·ªã lo·∫°i n·ªôi dung n√†y]'};
        }
        addMessageToChat(id, m, true);
      }
      statusEl.textContent='ƒêang nh·∫≠n c·∫≠p nh·∫≠t...';
    } catch {
      statusEl.textContent='CORS ho·∫∑c m·∫°ng l·ªói khi getUpdates';
    }
  }

  // g·ª≠i tin nh·∫Øn (c√≥ reply)
  async function sendMessage() {
    const text = inputEl.value.trim();
    if (!text) return;
    if (!token) { alert('B·∫°n c·∫ßn nh·∫≠p token.'); return; }
    if (!activeChatId) { alert('H√£y ch·ªçn cu·ªôc tr√≤ chuy·ªán.'); return; }
    const body = { chat_id: activeChatId, text };
    if (replyTo) body.reply_to_message_id = parseInt(replyTo,10);
    inputEl.value = '';
    clearReplyContext();
    stopChatAction();
    try {
      const sent = await botPost('sendMessage', body);
      if (sent.ok) {
        const msg = sent.result;
        const m = {
          id: msg.message_id,
          side: 'right',
          type: 'text',
          text,
          date: msg.date*1000,
          fromName: 'B·∫°n',
          reply_to: body.reply_to_message_id,
          reply_preview: replyTo? snippet(body.text):null
        };
        if (!chats.has(activeChatId)) {
          chats.set(activeChatId,{
            id:activeChatId,type:'unknown',
            title:'Chat '+activeChatId,
            avatarText:initials(activeChatId),
            messages:[],messageIds:new Set(),
            lastText:'',lastDate:0,unread:0
          });
        }
        addMessageToChat(activeChatId, m, false);
      } else {
        alert('G·ª≠i th·∫•t b·∫°i: '+(sent.description||'Kh√¥ng r√µ'));
      }
    } catch(e) {
      alert('L·ªói m·∫°ng khi g·ª≠i tin nh·∫Øn: '+ e.message);
    }
  }

  // g·ª≠i file
  async function sendSelectedFile(file) {
    if (!file||!activeChatId) { alert('Ch∆∞a ch·ªçn chat ho·∫∑c t·ªáp.'); return; }
    const caption = inputEl.value.trim();
    inputEl.value='';
    clearReplyContext();
    stopChatAction();
    const fd = new FormData();
    fd.append('chat_id', activeChatId);
    if (caption) fd.append('caption', caption);
    let method='sendDocument', field='document', type='document';
    if (file.type.startsWith('image/')) { method='sendPhoto'; field='photo'; type='photo'; }
    else if (file.type.startsWith('video/')) { method='sendVideo'; field='video'; type='video'; }
    else if (file.type.startsWith('audio/')) { method='sendAudio'; field='audio'; type='audio'; }
    fd.append(field, file, file.name||undefined);
    try {
      const res = await botForm(method, fd);
      if (res.ok) {
        const msg = res.result;
        let mediaUrl='', fileName=file.name||'';
        if (type==='photo') {
          const p = msg.photo[msg.photo.length-1];
          mediaUrl = await getFileUrl(p.file_id);
        } else if (type==='video') {
          mediaUrl = await getFileUrl(msg.video.file_id);
        } else if (type==='audio') {
          mediaUrl = await getFileUrl(msg.audio.file_id);
        } else {
          mediaUrl = await getFileUrl(msg.document.file_id);
          fileName = msg.document.file_name||fileName;
        }
        const m = {
          id: msg.message_id,
          side: 'right',
          type, mediaUrl, caption,
          fileName, date: msg.date*1000, fromName:'B·∫°n'
        };
        if (!chats.has(activeChatId)) {
          chats.set(activeChatId,{
            id:activeChatId,type:'unknown',
            title:'Chat '+activeChatId,
            avatarText:initials(activeChatId),
            messages:[],messageIds:new Set(),
            lastText:'',lastDate:0,unread:0
          });
        }
        addMessageToChat(activeChatId, m, false);
      } else {
        alert('G·ª≠i t·ªáp th·∫•t b·∫°i: '+(res.description||'Kh√¥ng r√µ'));
      }
    } catch(e) {
      alert('L·ªói m·∫°ng khi g·ª≠i t·ªáp: '+e.message);
    }
  }

  // s·ª± ki·ªán
  sendBtn.addEventListener('click', sendMessage);
  inputEl.addEventListener('keydown', e=>{ if(e.key==='Enter') sendMessage(); });
  inputEl.addEventListener('focus', startChatAction);
  inputEl.addEventListener('blur', stopChatAction);

  attachBtn.addEventListener('click', ()=>{
    if (!activeChatId) { alert('Ch·ªçn chat tr∆∞·ªõc.'); return; }
    stopChatAction();
    fileInputEl.value='';
    fileInputEl.accept='*/*';
    fileInputEl.click();
  });
  fileInputEl.addEventListener('change', ()=>{
    const f = fileInputEl.files[0];
    if (f) sendSelectedFile(f);
  });

  settingsBtn.addEventListener('click', ()=>{ overlayEl.classList.remove('hidden'); tokenInputEl.value=token; });
  cancelBtn.addEventListener('click', ()=>overlayEl.classList.add('hidden'));
  saveBtn.addEventListener('click', ()=>{
    token = tokenInputEl.value.trim();
    if (!token) { settingsHintEl.textContent='‚ùå Nh·∫≠p Bot Token!'; return; }
    localStorage.setItem('bot_token', token);
    overlayEl.classList.add('hidden');
    connect();
  });
  testBtn.addEventListener('click', testConnection);
  deleteWebhookBtn.addEventListener('click', deleteWebhook);
  notifBtn.addEventListener('click', requestNotifications);

  // kh·ªüi t·∫°o
  if (!token) {
    overlayEl.classList.remove('hidden');
  } else {
    connect();
  }
  </script>
</body>
</html>